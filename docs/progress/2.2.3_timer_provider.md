# 2.2.3 - Provider de Temporizador

**Fecha:** 2025-01-16  
**Rama:** `feature/timer-state-provider`  
**Estado:** ‚úÖ Completada  

---

## üìã Resumen

Implementaci√≥n del provider global de temporizador (`timerStateProvider`) utilizando `StateNotifierProvider` de Riverpod. Este provider gestiona el estado completo del temporizador incluyendo inicio, pausa, reanudaci√≥n, completado y detenci√≥n.

---

## üéØ Objetivos de la Tarea

- [x] Crear `lib/presentation/providers/timer_provider.dart`
- [x] Implementar `TimerStatus` enum con los estados: stopped, running, paused, completed
- [x] Implementar `TimerState` clase inmutable con toda la informaci√≥n del timer
- [x] Implementar `TimerNotifier` con l√≥gica completa del temporizador
- [x] Crear `timerStateProvider` usando `StateNotifierProvider`
- [x] Incluir documentaci√≥n y ejemplos de uso
- [x] Verificar con `flutter analyze` (0 issues)

---

## üìÇ Archivos Modificados

### Creados
- `lib/presentation/providers/timer_provider.dart` (267 l√≠neas)

### Modificados
- `docs/TASK_BREAKDOWN.md` (marcado como completada)

---

## üèóÔ∏è Implementaci√≥n

### 1. TimerStatus Enum

```dart
enum TimerStatus {
  stopped,   // No iniciado o reseteado
  running,   // En ejecuci√≥n
  paused,    // Pausado
  completed, // Tiempo agotado
}
```

### 2. TimerState (Estado Inmutable)

**Propiedades:**
- `status`: Estado actual del temporizador
- `remainingSeconds`: Tiempo restante en segundos
- `totalSeconds`: Duraci√≥n total configurada
- `taskId`: ID opcional de tarea asociada
- `error`: Mensaje de error si aplica

**Getters Calculados:**
- `progress`: Porcentaje de progreso (0.0 a 1.0)
- `isActive`: Indica si est√° corriendo o pausado

**M√©todos:**
- `copyWith()`: Crea copias inmutables con valores modificados
- Constructor named: `TimerState.initial()`
- `==` y `hashCode` sobrescritos para comparaciones
- `toString()` para debugging

### 3. TimerNotifier (L√≥gica del Temporizador)

**Estado Interno:**
- `Timer? _timer`: Timer peri√≥dico de Dart
- `void Function()? _onCompleted`: Callback opcional

**M√©todos P√∫blicos:**

#### `start()`
```dart
void start({
  required int durationInSeconds,
  String? taskId,
  void Function()? onCompleted,
})
```
- Inicia el temporizador con duraci√≥n espec√≠fica
- Valida que la duraci√≥n sea > 0
- Cancela timer anterior si existe
- Inicia tick cada segundo

#### `pause()`
- Pausa el temporizador si est√° running
- Cancela el timer interno
- Cambia status a `paused`

#### `resume()`
- Reanuda desde pausa
- Reinicia el tick del timer
- Cambia status a `running`

#### `complete()`
- Completa manualmente el temporizador
- Ejecuta callback `onCompleted` si existe

#### `stop()`
- Detiene y resetea completamente
- Cancela timer y limpia callbacks
- Vuelve a `TimerState.initial()`

#### `addTime(int additionalSeconds)`
- A√±ade tiempo extra al temporizador
- Actualiza `remainingSeconds` y `totalSeconds`

#### `dispose()`
- Limpia recursos (cancela timer)
- Sobrescribe m√©todo de `StateNotifier`

### 4. Provider Global

```dart
final timerStateProvider = StateNotifierProvider<TimerNotifier, TimerState>((ref) {
  return TimerNotifier();
});
```

---

## üí° Ejemplo de Uso

```dart
// En un widget o controlador

// 1. Iniciar timer de 25 minutos (Pomodoro)
ref.read(timerStateProvider.notifier).start(
  durationInSeconds: 25 * 60,
  taskId: 'task-123',
  onCompleted: () {
    print('¬°Timer completado!');
    // Aqu√≠ se puede mostrar notificaci√≥n, guardar en DB, etc.
  },
);

// 2. Pausar
ref.read(timerStateProvider.notifier).pause();

// 3. Reanudar
ref.read(timerStateProvider.notifier).resume();

// 4. Obtener estado actual (en build method)
final timerState = ref.watch(timerStateProvider);

if (timerState.status == TimerStatus.running) {
  final minutes = timerState.remainingSeconds ~/ 60;
  final seconds = timerState.remainingSeconds % 60;
  print('Tiempo restante: $minutes:${seconds.toString().padLeft(2, '0')}');
}

// 5. A√±adir 5 minutos extra
ref.read(timerStateProvider.notifier).addTime(5 * 60);

// 6. Detener completamente
ref.read(timerStateProvider.notifier).stop();
```

---

## ‚úÖ Validaci√≥n

### Flutter Analyze
```bash
flutter analyze
# ‚úÖ No issues found!
```

### Arquitectura
- ‚úÖ Ubicaci√≥n correcta: `lib/presentation/providers/`
- ‚úÖ Usa `StateNotifierProvider` (recomendado para l√≥gica compleja)
- ‚úÖ Estado inmutable con `@immutable` annotation
- ‚úÖ Separaci√≥n de responsabilidades (State vs Notifier)

### Documentaci√≥n
- ‚úÖ Comentarios en todos los m√©todos y propiedades
- ‚úÖ Ejemplo de uso incluido
- ‚úÖ Estados del enum documentados

---

## üîó Decisiones de Dise√±o

### 1. **Timer Peri√≥dico vs Stream**
- **Decisi√≥n:** Usar `Timer.periodic` de Dart
- **Raz√≥n:** M√°s simple y directo para decrementar cada segundo
- **Alternativa considerada:** Stream.periodic (m√°s complejo sin beneficio claro)

### 2. **Estado Inmutable**
- **Decisi√≥n:** `TimerState` con propiedades final y `copyWith()`
- **Raz√≥n:** Patr√≥n recomendado de Riverpod para predictibilidad
- **Beneficio:** Facilita debugging y testing

### 3. **Callback onCompleted**
- **Decisi√≥n:** Callback opcional en m√©todo `start()`
- **Raz√≥n:** Permite acciones personalizadas (notificaciones, guardar DB, etc.)
- **Alternativa:** Escuchar cambios en el provider (m√°s verboso)

### 4. **Gesti√≥n de Recursos**
- **Decisi√≥n:** Cancelar timer en `dispose()`, `stop()` y antes de crear nuevo
- **Raz√≥n:** Prevenir memory leaks y timers hu√©rfanos
- **Cr√≠tico:** Flutter mantiene providers vivos seg√∫n su scope

### 5. **Granularidad del Tick**
- **Decisi√≥n:** Tick cada 1 segundo
- **Raz√≥n:** Balance entre precisi√≥n y rendimiento para un timer de tareas
- **Nota:** Si se necesita m√°s precisi√≥n (milisegundos), se puede ajustar f√°cilmente

---

## üîÑ Integraci√≥n Futura (Sprint 2)

**Cuando existan las entidades de dominio:**

```dart
// TODO Sprint 2: Integrar con TaskRepository
// - Guardar tiempo transcurrido en la tarea
// - Actualizar estad√≠sticas de tiempo
// - Sincronizar con base de datos

// TODO Sprint 2: Integrar con NotificationService
// - Mostrar notificaci√≥n al completar
// - Sonido de alerta opcional

// TODO Sprint 2: Integrar con AnalyticsService
// - Trackear tiempo total trabajado
// - Estad√≠sticas de productividad
```

---

## üìä Relaci√≥n con Otros Providers

```
ProviderScope (main.dart)
    ‚îú‚îÄ‚îÄ taskListProvider (gesti√≥n de tareas)
    ‚îú‚îÄ‚îÄ timerStateProvider ‚Üê ESTE PROVIDER
    ‚îî‚îÄ‚îÄ databaseProvider (pr√≥ximo: 2.2.4)
```

**Comunicaci√≥n futura:**
- `timerStateProvider` guardar√° tiempo en `taskListProvider` cuando se complete
- `timerStateProvider` persistir√° estado en `databaseProvider` para recuperaci√≥n

---

## üß™ Testing (Sprint 3)

**Unit Tests a crear:**
- [ ] Test `start()` con diferentes duraciones
- [ ] Test `pause()` y `resume()` mantienen tiempo correcto
- [ ] Test `complete()` ejecuta callback
- [ ] Test `stop()` resetea a estado inicial
- [ ] Test `addTime()` modifica correctamente
- [ ] Test timer decrementa cada segundo
- [ ] Test dispose cancela timer
- [ ] Test validaciones (duraci√≥n <= 0)

---

## üìù Checklist de Pull Request

### 1. Descripci√≥n del Cambio
- **Tipo de cambio:** Nueva funcionalidad (feat)
- **Alcance:** Provider de temporizador global
- **Descripci√≥n:** Implementaci√≥n de `timerStateProvider` con l√≥gica completa de inicio, pausa, reanudaci√≥n y completado. Utiliza `StateNotifierProvider` de Riverpod para gestionar estado inmutable del timer.

### 2. Motivaci√≥n y Contexto
- **¬øPor qu√© es necesario este cambio?** Cumple con la tarea 2.2.3 del TASK_BREAKDOWN. Es fundamental para la funcionalidad Pomodoro del Task Timer App.
- **¬øQu√© problema resuelve?** Proporciona gesti√≥n centralizada del temporizador accesible desde cualquier parte de la app.
- **Issue relacionado:** Tarea 2.2.3

### 3. Tipo de Cambio
- [x] Nueva funcionalidad (feat)
- [ ] Correcci√≥n de bug (fix)
- [ ] Actualizaci√≥n de documentaci√≥n (docs)
- [ ] Refactorizaci√≥n (refactor)
- [ ] Mejora de rendimiento (perf)
- [ ] Tests (test)
- [ ] Configuraci√≥n (chore)

### 4. Checklist de C√≥digo
- [x] El c√≥digo sigue las gu√≠as de estilo del proyecto (analysis_options.yaml)
- [x] He realizado una auto-revisi√≥n de mi c√≥digo
- [x] He comentado √°reas complejas del c√≥digo
- [x] He actualizado la documentaci√≥n correspondiente
- [x] Mis cambios no generan nuevos warnings
- [x] `flutter analyze` pasa sin errores
- [ ] He a√±adido tests que prueban mi soluci√≥n (Sprint 3)
- [ ] Los tests nuevos y existentes pasan localmente (Sprint 3)

### 5. Pruebas Realizadas
- [x] `flutter analyze` - ‚úÖ No issues found
- [x] Revisi√≥n de documentaci√≥n inline
- [x] Verificaci√≥n de anotaci√≥n `@immutable`
- [ ] Tests unitarios (pendiente Sprint 3)
- [ ] Tests de integraci√≥n (pendiente Sprint 3)

### 6. Screenshots / Videos
N/A - Es un provider sin UI directa. El UI del timer se implementar√° en Sprint 2.

### 7. Impacto
- **√Åreas afectadas:** `lib/presentation/providers/`
- **Breaking changes:** No
- **Dependencias nuevas:** Ninguna (usa flutter_riverpod ya instalado)

### 8. Arquitectura
- [x] Cumple con Clean Architecture (Capa Presentation)
- [x] Sigue patr√≥n MVVM
- [x] Usa Riverpod correctamente (`StateNotifierProvider`)
- [x] Estado inmutable con `copyWith()`
- [x] Separaci√≥n de responsabilidades (State vs Notifier)

### 9. Performance
- [x] No introduce memory leaks (timer cancelado en dispose)
- [x] Uso eficiente de recursos (tick cada 1 segundo)
- [x] No bloquea el UI thread

### 10. Seguridad
- [x] Validaci√≥n de entrada (duraci√≥n > 0)
- N/A - No maneja datos sensibles
- N/A - No hay llamadas de red

### 11. Accesibilidad
N/A - Provider sin UI

### 12. Compatibilidad
- [x] Compatible con Flutter 3.19+
- [x] Compatible con Dart 3.3+
- [x] Funciona en Android, iOS, Web, Windows, macOS, Linux

### 13. Documentaci√≥n
- [x] README actualizado: N/A
- [x] Comentarios de c√≥digo completos
- [x] Ejemplo de uso incluido en el provider
- [x] TASK_BREAKDOWN.md actualizado
- [x] Documento de progreso creado (`docs/progress/2.2.3_timer_provider.md`)

### 14. Revisi√≥n
- [x] He revisado mi propio c√≥digo antes de solicitar revisi√≥n
- [x] He verificado que no hay console.logs o c√≥digo de debug
- [x] He verificado que los nombres de variables/funciones son descriptivos

### 15. Git
- [x] Commit sigue Conventional Commits
- [x] Mensaje de commit es descriptivo
- [x] Rama feature correcta: `feature/timer-state-provider`

### 16. Migraciones / Cambios de DB
N/A - No hay cambios de base de datos

### 17. Configuraci√≥n
- [x] No requiere cambios de configuraci√≥n
- [x] No requiere variables de entorno
- [x] No requiere permisos adicionales

### 18. Notas Adicionales para Revisores

**Puntos clave a revisar:**
1. **Gesti√≥n de recursos:** Verificar que el `Timer` se cancela correctamente en todos los escenarios (dispose, stop, nuevo start)
2. **Inmutabilidad:** Confirmar que `TimerState` es verdaderamente inmutable
3. **L√≥gica del tick:** Revisar que el decremento cada segundo es correcto
4. **Callback onCompleted:** Verificar que se ejecuta solo cuando corresponde

**Decisiones importantes:**
- Se us√≥ `Timer.periodic` en lugar de `Stream` para simplicidad
- El tick es cada 1 segundo (suficiente para un timer de tareas)
- El estado incluye `taskId` opcional para vincular con tareas en el futuro

**Pr√≥ximos pasos:**
- Sprint 2: Integrar con entidades de dominio y repository
- Sprint 2: Conectar con UI del timer
- Sprint 3: Crear tests unitarios exhaustivos

---

## üîÑ Estado del Workflow

- [x] Pre-Task Checklist completado
- [x] Rama feature creada: `feature/timer-state-provider`
- [x] C√≥digo implementado
- [x] Validaciones pasadas
- [x] Documentaci√≥n creada
- [ ] Commit realizado (siguiente paso)
- [ ] Push a GitHub (siguiente paso)
- [ ] Merge a develop (siguiente paso)

---

**Siguiente acci√≥n:** Realizar commit y push siguiendo Conventional Commits.
